<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Assistant Vocal iPhone Style Ultra-Rapide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'] },
                    borderRadius: { '4xl': '2rem', '5xl': '2.5rem' },
                    keyframes: {
                        pulse: { '0%, 100%': { boxShadow: '0 0 0 0 rgba(74, 222, 128, 0.7)' }, '70%': { boxShadow: '0 0 0 10px rgba(74, 222, 128, 0)' } },
                        'tts-pulse': { '0%, 100%': { boxShadow: '0 0 0 0 rgba(168, 85, 247, 0.7)' }, '70%': { boxShadow: '0 0 0 10px rgba(168, 85, 247, 0)' } },
                        'interrupt-flash': { '0%': { boxShadow: '0 0 0 0 rgba(239, 68, 68, 0.8)' }, '50%': { boxShadow: '0 0 0 15px rgba(239, 68, 68, 0.4)' }, '100%': { boxShadow: '0 0 0 0 rgba(239, 68, 68, 0)' } },
                        'processing-spin': { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' } },
                    },
                    animation: {
                        pulse: 'pulse 2s infinite', 'tts-pulse': 'tts-pulse 1.5s infinite',
                        'interrupt-flash': 'interrupt-flash 0.5s ease-out', 'processing-spin': 'processing-spin 1s linear infinite',
                    },
                },
            },
        }
    </script>
    <style>
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 10px; }
        .backdrop-blur-xl {
             -webkit-backdrop-filter: blur(24px); /* MODIFI√â: Ajout pour compatibilit√© Safari */
             backdrop-filter: blur(24px);
        }
        #toggleButton { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform-origin: center; }
        #toggleButton:active { transform: scale(0.95); }
        #toggleButton:disabled { transform: scale(1); opacity: 0.5; }
    </style>
</head>
<body class="bg-gradient-to-br from-[#1e3a8a] to-[#3730a3] min-h-screen flex items-center justify-center font-sans text-white overflow-hidden">

    <div class="w-full h-full bg-gradient-to-br from-[#1e3c72]/80 to-[#2a5298]/80 relative flex flex-col">
        <div class="fixed top-0 left-0 w-full z-20">
            <div class="flex justify-between items-center px-5 py-3 text-white text-sm font-semibold">
                <button id="conversationToggle" class="p-2 rounded-lg bg-white/10 hover:bg-white/20 transition-colors"> <i data-lucide="message-square-text" class="w-5 h-5"></i> </button>
                <div id="time" class="font-bold">9:41</div>
                <button id="drawerToggle" class="p-2 rounded-lg bg-white/10 hover:bg-white/20 transition-colors"> <i data-lucide="sliders-horizontal" class="w-5 h-5"></i> </button>
            </div>
        </div>
        
        <div class="flex-1 flex flex-col justify-center items-center px-5 pt-16 pb-48">
            <div class="relative flex-shrink-0 text-center">
                <div id="voice-circle" class="w-[200px] h-[200px] rounded-full mx-auto mb-2.5 flex items-center justify-center text-6xl transition-all duration-300 bg-white/10 backdrop-blur-xl border-2 border-white/20">
                    <i data-lucide="power-off" class="w-16 h-16"></i>
                </div>
                <div id="status-text" class="text-center text-white text-lg font-medium">Pr√™t √† d√©marrer</div>
                <div id="interrupt-indicator" class="absolute -bottom-8 left-1/2 -translate-x-1/2 bg-red-500/80 text-white px-4 py-2 rounded-full text-xs opacity-0 transition-opacity duration-300">Interruption !</div>
                <div id="processing-indicator" class="absolute -bottom-16 left-1/2 -translate-x-1/2 bg-blue-500/80 text-white px-4 py-2 rounded-full text-xs opacity-0 transition-opacity duration-300">‚ö° Traitement...</div>
            </div>
        </div>

        <div class="fixed bottom-0 left-0 w-full z-20 p-4 bg-gradient-to-t from-[#1e3a8a] to-transparent">
             <div class="max-w-md mx-auto space-y-3">
                <button id="toggleButton" class="w-full py-4 rounded-2xl font-semibold text-base transition-all backdrop-blur-xl bg-green-500/80 text-white disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                    <i data-lucide="mic" id="toggleIconEl"></i> <span id="toggleText">D√©marrer</span>
                </button>
                <div class="flex justify-center items-center gap-2">
                    <button id="modeContinu" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-all bg-green-500/80 text-white"> üîÑ Continu </button>
                    <button id="modePushToTalk" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-all bg-white/20 text-white/70 hover:bg-white/30"> üé§ Push-to-Talk </button>
                </div>
                <div class="flex gap-2">
                    <input type="text" id="text-input" placeholder="Envoyer un message..." class="flex-1 bg-white/10 border border-white/20 rounded-xl px-4 py-3 text-white text-sm placeholder-white/60 focus:outline-none focus:border-green-400/50 focus:bg-white/15">
                    <button id="send-button" class="p-3 bg-green-500/80 rounded-xl text-white hover:bg-green-500/100 transition-colors"> <i data-lucide="send-horizontal" class="w-6 h-6"></i> </button>
                </div>
            </div>
        </div>
    </div>

    <audio id="ttsAudio" style="display: none;" playsinline></audio>

    <div id="conversationDrawer" class="fixed inset-y-0 left-0 z-50 w-full sm:w-96 bg-gradient-to-b from-[#19356d] to-[#26488b] shadow-xl transform -translate-x-full transition-transform duration-300 ease-in-out flex flex-col">
        <div class="flex items-center justify-between p-4 border-b border-white/20 flex-shrink-0">
            <h2 class="text-white text-lg font-semibold">üí¨ Conversation</h2>
            <button id="conversationDrawerClose" class="text-white/70 hover:text-white transition-colors"> <i data-lucide="x" class="w-6 h-6"></i> </button>
        </div>
        <div id="conversationHistory" class="p-4 overflow-y-auto flex-1">
            <div class="text-white/60 text-center italic mt-10"> L'historique de la conversation appara√Ætra ici... </div>
        </div>
    </div>
    
    <div id="settingsDrawer" class="fixed inset-y-0 right-0 z-50 w-full sm:w-96 bg-gradient-to-b from-[#19356d] to-[#26488b] shadow-xl transform translate-x-full transition-transform duration-300 ease-in-out flex flex-col">
        <div class="flex items-center justify-between p-4 border-b border-white/20 flex-shrink-0">
            <h2 class="text-white text-lg font-semibold">‚öôÔ∏è Panneau de contr√¥le</h2>
            <button id="settingsDrawerClose" class="text-white/70 hover:text-white transition-colors"> <i data-lucide="x" class="w-6 h-6"></i> </button>
        </div>
        <div class="p-4 space-y-4 overflow-y-auto flex-1">
            <div class="bg-white/10 backdrop-blur-xl rounded-xl p-4 border border-white/20">
                <h3 class="text-white font-medium mb-3">üîß Param√®tres</h3>
                <input type="password" id="drawerGroqKey" placeholder="Cl√© API Groq (STT)" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white text-sm placeholder-white/60 focus:outline-none focus:border-green-400/50 focus:bg-white/15 mb-3">
                <input type="password" id="drawerOpenaiKey" placeholder="Cl√© API OpenAI (LLM)" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white text-sm placeholder-white/60 focus:outline-none focus:border-green-400/50 focus:bg-white/15 mb-3">
                <div class="grid grid-cols-2 gap-3 text-sm mt-3">
                    <label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" id="drawerAutoSpeak" class="accent-green-400"> Auto TTS</label>
                    <label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" id="drawerAllowInterrupt" class="accent-green-400"> Interruption</label>
                </div>
                <select id="drawerVoiceSelect" class="w-full mt-3 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white text-sm appearance-none">
                    <option value="fr-FR-DeniseNeural">Voix: Denise</option> <option value="fr-FR-EloiseNeural">Voix: Eloise</option>
                    <option value="fr-FR-FabriceNeural">Voix: Fabrice</option> <option value="fr-FR-HenriNeural">Voix: Henri</option>
                </select>
            </div>
             <div class="bg-white/10 backdrop-blur-xl rounded-xl p-4 border border-white/20">
                <h3 class="text-white font-medium mb-3">‚ö° Actions</h3>
                <div class="space-y-2">
                    <button id="drawerClearCache" class="w-full flex items-center justify-center gap-2 py-2 bg-red-500/80 hover:bg-red-500 rounded-lg text-white text-sm transition-colors"><i data-lucide="trash-2" class="w-4 h-4"></i> Vider le cache</button>
                    <button id="drawerExportConversation" class="w-full flex items-center justify-center gap-2 py-2 bg-blue-500/80 hover:bg-blue-500 rounded-lg text-white text-sm transition-colors"><i data-lucide="download" class="w-4 h-4"></i> Exporter</button>
                </div>
            </div>
            <div class="bg-white/10 backdrop-blur-xl rounded-xl p-4 border border-white/20">
                <h3 class="text-white font-medium mb-3">üîç Log de d√©bogage</h3>
                <div id="drawerDebug" class="bg-black/20 rounded-lg p-3 text-xs text-white/70 h-48 overflow-y-auto">
                    <div>‚ö° Syst√®me pr√™t...</div>
                </div>
            </div>
        </div>
    </div>

    <div id="drawerOverlay" class="fixed inset-0 bg-black/50 z-40 opacity-0 pointer-events-none transition-opacity duration-300"></div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.22/dist/bundle.min.js"></script>
    
    <script>
    // =============================================
    // üöÄ ASSISTANT VOCAL ULTRA-RAPIDE COMPLET
    // =============================================
    
    // üîß DOM & STATE VARIABLES
    let myVad = null;
    let conversationHistory = [];
    let isPlaying = false;
    let isProcessingTTS = false;
    let pipelineActive = false;
    let lastPlayedReflection = "";
    let recordingMode = 'continu';
    let isPushToTalkRecording = false;
    let isContinuRecording = false;
    let pushToTalkAudio = [];
    let isAudioUnlocked = false; // NOUVEAU: Pour g√©rer le d√©verrouillage audio sur iOS/Safari
    const ttsCache = new Map();
    const MAX_CACHE_SIZE = 50;
    const baseCircleClasses = "w-[200px] h-[200px] rounded-full mx-auto mb-2.5 flex items-center justify-center text-6xl transition-all duration-300 backdrop-blur-xl";

    let toggleButton, toggleIconEl, toggleText, voiceCircle, statusText, ttsAudio;
    let modeContinu, modePushToTalk;
    
    // üí≠ SIMPLE REFLECTIONS
    const SIMPLE_REFLECTIONS = ["Ah oui, je vois...", "D'accord...", "OK, je comprends...", "Hmm, int√©ressant...", "Oui, effectivement...", "Ah, parfait...", "Tr√®s bien...", "Laissez-moi voir...", "Bien s√ªr...", "Oui, d'accord...", "Je vois..."];
    let reflectionAudios = new Map();
    
    // =============================================
    // üîß UTILITY & UI FUNCTIONS
    // =============================================
    function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const emoji = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ö°';
        console.log(`${timestamp} ${emoji} ${message}`);
        const drawerDebug = document.getElementById('drawerDebug');
        if (drawerDebug) {
            const newLine = document.createElement('div');
            newLine.textContent = `${timestamp} ${emoji} ${message}`;
            const typeClass = { error: 'text-red-300', success: 'text-green-300', warning: 'text-yellow-300' };
            newLine.className = typeClass[type] || '';
            drawerDebug.insertBefore(newLine, drawerDebug.firstChild);
            if (drawerDebug.children.length > 50) drawerDebug.removeChild(drawerDebug.lastChild);
        }
    }

    function updateStatus(text, iconName, stateClass) {
        if (!statusText || !voiceCircle) return;
        statusText.textContent = text;
        voiceCircle.innerHTML = `<i data-lucide="${iconName}" class="w-16 h-16 ${stateClass === 'processing' ? 'animate-spin' : ''}"></i>`;
        document.getElementById('processing-indicator')?.classList.toggle('opacity-100', stateClass === 'processing');
        let stateClasses = "";
        switch (stateClass) {
            case "listening": stateClasses = "bg-green-400/20 border-2 border-green-400/40 animate-pulse"; break;
            case "speaking": stateClasses = "bg-green-600/30 border-2 border-green-600/50"; break;
            case "processing": stateClasses = "bg-amber-400/20 border-2 border-amber-400/40"; break;
            case "tts-playing": stateClasses = "bg-purple-500/20 border-2 border-purple-500/40 animate-tts-pulse"; break;
            case "interrupted": stateClasses = "bg-red-500/20 border-2 border-red-500/40 animate-interrupt-flash"; break;
            default: stateClasses = "bg-white/10 border-2 border-white/20";
        }
        voiceCircle.className = `${baseCircleClasses} ${stateClasses}`;
        lucide.createIcons();
    }
    
    function updateButtonState() {
        if (!toggleButton || !toggleIconEl || !toggleText) return;
        let isRecording = isContinuRecording || isPushToTalkRecording;
        toggleButton.disabled = isPlaying || isProcessingTTS;
        const baseClass = "w-full py-4 rounded-2xl font-semibold text-base transition-all backdrop-blur-xl text-white flex items-center justify-center gap-2";
        if (recordingMode === 'push-to-talk') {
            if (isPushToTalkRecording) {
                toggleButton.className = `${baseClass} bg-red-500/80 hover:bg-red-600/80 animate-pulse`;
                toggleIconEl.setAttribute('data-lucide', 'square');
                toggleText.textContent = 'Envoyer';
            } else {
                toggleButton.className = `${baseClass} bg-blue-500/80 hover:bg-blue-600/80`;
                toggleIconEl.setAttribute('data-lucide', 'mic');
                toggleText.textContent = 'Maintenir & Parler';
            }
        } else { // Continu
            const baseClassDisabled = "w-full py-4 rounded-2xl font-semibold text-base transition-all backdrop-blur-xl text-white disabled:opacity-50 flex items-center justify-center gap-2";
            if (isContinuRecording) {
                toggleButton.className = `${baseClassDisabled} bg-red-500/80 hover:bg-red-600/80`;
                toggleIconEl.setAttribute('data-lucide', 'mic-off');
                toggleText.textContent = 'Arr√™ter';
            } else {
                toggleButton.className = `${baseClassDisabled} bg-green-500/80 hover:bg-green-600/80`;
                toggleIconEl.setAttribute('data-lucide', 'mic');
                toggleText.textContent = 'D√©marrer';
            }
        }
        lucide.createIcons();
    }

    // =============================================
    // üé§ RECORDING & VAD
    // =============================================
    // NOUVEAU: Fonction pour d√©verrouiller l'audio sur iOS/Safari
    function unlockAudioContext() {
        if (isAudioUnlocked) return;
        log('Tentative de d√©verrouillage audio...', 'warning');
        const silentSound = "data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhIAAAAAA=";
        const audio = new Audio(silentSound);
        audio.play().then(() => {
            isAudioUnlocked = true;
            log('‚úÖ Audio d√©verrouill√© avec succ√®s !', 'success');
        }).catch(e => console.error("Erreur d√©verrouillage audio", e));
    }

    async function requestMicrophonePermission() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(track => track.stop());
            log('Permission microphone accord√©e', 'success');
            return true;
        } catch (error) {
            log('Permission microphone refus√©e ou non disponible.', 'error');
            alert("Veuillez autoriser l'acc√®s au microphone pour utiliser l'assistant vocal.");
            return false;
        }
    }
    
    async function handleMasterToggle() {
        unlockAudioContext(); // Tentative de d√©verrouillage √† chaque interaction principale

        if (recordingMode === 'continu') {
            if (isContinuRecording) await stopAllRecording();
            else await startContinuRecording();
        } else {
            if (isPushToTalkRecording) await stopPushToTalkRecording();
            else await startPushToTalkRecording();
        }
    }

    async function startContinuRecording() {
        const hasPermission = await requestMicrophonePermission();
        if (!hasPermission) return;
        
        toggleButton.disabled = true;
        updateStatus("Initialisation...", "loader-circle", "processing");

        try {
            await preGenerateSimpleReflections();
            myVad = await vad.MicVAD.new({
                onSpeechStart: () => { if (!interruptTTS()) updateStatus("Vous parlez...", "mic", "speaking"); },
                onSpeechEnd: (audio) => {
                    playRandomReflection();
                    if (!isProcessingTTS && audio.length > 600) transcribeAudioUltraFast(audio);
                    else if (myVad) updateStatus("En √©coute...", "mic", "listening");
                },
            });
            myVad.start();
            isContinuRecording = true;
            updateStatus("En √©coute...", "mic", "listening");
        } catch (error) {
            log(`Erreur VAD: ${error.message}`, 'error');
            isContinuRecording = false;
        } finally {
            toggleButton.disabled = false;
            updateButtonState();
        }
    }
    
    async function startPushToTalkRecording() {
        const hasPermission = await requestMicrophonePermission();
        if (!hasPermission) return;
        
        updateStatus("Parlez maintenant...", "mic", "speaking");
        try {
            myVad = await vad.MicVAD.new({ onSpeechEnd: (audio) => { pushToTalkAudio.push(...audio); } });
            myVad.start();
            pushToTalkAudio = [];
            isPushToTalkRecording = true;
            updateButtonState();
        } catch (error) {
            isPushToTalkRecording = false;
            updateButtonState();
        }
    }

    async function stopPushToTalkRecording() {
        if (myVad) { myVad.destroy(); myVad = null; }
        isPushToTalkRecording = false;
        updateButtonState();
        if (pushToTalkAudio.length > 1000) {
            updateStatus("Traitement...", "loader-circle", "processing");
            await transcribeAudioUltraFast(new Float32Array(pushToTalkAudio));
        } else {
            updateStatus("Pr√™t", "power-off", "");
        }
        pushToTalkAudio = [];
    }

    async function stopAllRecording() {
        if (myVad) { myVad.destroy(); myVad = null; }
        await cleanupPipeline();
        reflectionAudios.forEach(URL.revokeObjectURL);
        reflectionAudios.clear();
        isContinuRecording = false;
        isPushToTalkRecording = false;
        updateButtonState();
        updateStatus("Pr√™t", "power-off", "");
    }
    
    // =============================================
    // üîä TTS & AUDIO PROCESSING
    // =============================================
    // NOUVEAU: Fonction centralis√©e pour jouer l'audio
    async function playAudioFromUrl(url) {
        return new Promise((resolve, reject) => {
            ttsAudio.onended = resolve;
            ttsAudio.onerror = reject;
            ttsAudio.src = url;
            ttsAudio.play().catch(e => {
                log('Erreur de lecture, l\'audio n\'est peut-√™tre pas d√©verrouill√©.', 'error');
                reject(e);
            });
        });
    }

    function playRandomReflection() {
        if (isPlaying || reflectionAudios.size === 0) return;
        const randomReflection = SIMPLE_REFLECTIONS[Math.floor(Math.random() * SIMPLE_REFLECTIONS.length)];
        const audioUrl = reflectionAudios.get(randomReflection);
        if (audioUrl) {
            lastPlayedReflection = randomReflection;
            playAudioFromUrl(audioUrl).catch(() => {}); // Jouer sans attendre
        }
    }
    
    async function generateTTSForSentence(sentence, voice) {
        const cacheKey = `${voice}_${sentence}`;
        if (ttsCache.has(cacheKey)) return ttsCache.get(cacheKey);
        const response = await fetch("https://chatbot-20102024-8c94bbb4eddf.herokuapp.com/synthesize", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: sentence, voice: voice }),
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        if (ttsCache.size >= MAX_CACHE_SIZE) {
            const [firstKey, firstUrl] = ttsCache.entries().next().value;
            URL.revokeObjectURL(firstUrl); ttsCache.delete(firstKey);
        }
        ttsCache.set(cacheKey, audioUrl);
        return audioUrl;
    }

    async function playAudioPipeline(sentences, voice) {
        for (let i = 0; i < sentences.length && pipelineActive; i++) {
            while (!window.readyAudioBuffer.has(i) && pipelineActive) await new Promise(r => setTimeout(r, 50));
            if (!pipelineActive) break;
            const audioData = window.readyAudioBuffer.get(i);
            window.readyAudioBuffer.delete(i);
            updateStatus(`IA parle... (${i + 1}/${sentences.length})`, "volume-2", "tts-playing");
            await playAudioFromUrl(audioData.audioUrl);
        }
    }
    
  // REMPLACE CETTE FONCTION DANS TON CODE EXISTANT

async function speakTextWithPipeline(text) {
    if (isProcessingTTS) return;
    isProcessingTTS = isPlaying = pipelineActive = true;
    updateButtonState();

    const drawerVoiceSelect = document.getElementById('drawerVoiceSelect');
    const voice = drawerVoiceSelect ? drawerVoiceSelect.value : 'fr-FR-DeniseNeural';
    
    // S√©pare le texte en phrases. Le filtre `s.length > 1` est plus tol√©rant.
    const sentences = text.match(/[^.!?]+[.!?]*|[^.!?]+$/g)?.map(s => s.trim()).filter(s => s.length > 1) || [];

    if (sentences.length === 0) {
        log('Aucune phrase √† lire apr√®s d√©coupage.', 'warning');
        await cleanupPipeline();
        return;
    }
    
    log(`üöÄ D√©marrage pipeline TTS pour ${sentences.length} phrases`, 'info');
    window.readyAudioBuffer = new Map();

    try {
        // MODIFICATION CL√â : On s√©pare le g√©n√©rateur du lecteur.
        // 1. On lance le g√©n√©rateur de son en arri√®re-plan. Il va remplir le buffer.
        const generationWorker = (async () => {
            for (let i = 0; i < sentences.length && pipelineActive; i++) {
                // On attend seulement si le buffer est plein pour ne pas surcharger la m√©moire
                while (window.readyAudioBuffer.size >= 3 && pipelineActive) {
                    await new Promise(r => setTimeout(r, 100));
                }
                if (!pipelineActive) break; // Double v√©rification apr√®s la pause

                try {
                    const audioUrl = await generateTTSForSentence(sentences[i], voice);
                    if (pipelineActive) window.readyAudioBuffer.set(i, { audioUrl });
                } catch (err){
                    log(`Erreur g√©n√©ration phrase ${i}`, 'error');
                }
            }
        })();

        // 2. On attend la fin de la LECTURE. Le lecteur fera des pauses lui-m√™me
        //    s'il attend des phrases du g√©n√©rateur.
        await playAudioPipeline(sentences, voice);

    } catch (error) {
        log(`Erreur majeure dans le pipeline de lecture: ${error.message}`, 'error');
    } finally {
        // Le nettoyage n'est appel√© qu'apr√®s la fin de la lecture compl√®te.
        await cleanupPipeline();
    }
}
    async function cleanupPipeline() {
        pipelineActive = false; isProcessingTTS = false; isPlaying = false;
        if (window.readyAudioBuffer) window.readyAudioBuffer.forEach(data => URL.revokeObjectURL(data.audioUrl));
        updateButtonState();
        if (isContinuRecording) updateStatus("En √©coute...", "mic", "listening");
        else if (!isPushToTalkRecording) updateStatus("Pr√™t", "power-off", "");
    }

    function interruptTTS() {
        if ((isPlaying || isProcessingTTS) && document.getElementById('drawerAllowInterrupt').checked) {
            log('üõë TTS Interrompu !', 'warning');
            ttsAudio.pause(); ttsAudio.src = "";
            cleanupPipeline();
            updateStatus("Interruption !", "zap-off", "interrupted");
            document.getElementById('interrupt-indicator')?.classList.add('opacity-100');
            setTimeout(() => document.getElementById('interrupt-indicator')?.classList.remove('opacity-100'), 1500);
            return true;
        }
        return false;
    }

    // ... (Le reste des fonctions comme transcribeAudio, processUserMessage, etc. ne changent pas radicalement)
    // Seules les fonctions qui appellent .play() sont affect√©es et doivent maintenant utiliser `playAudioFromUrl`
    
    async function preGenerateSimpleReflections() { /* ... Idem */ }
    async function transcribeAudioUltraFast(audioData) { /* ... Idem */ }
    async function processUserMessage(userText) { /* ... Idem, mais la lecture se fait via speakTextWithPipeline qui est corrig√© */ }
    async function getLLMResponseStreaming(userMessage) { /* ... Idem */ }
    function addToConversation(type, content) { /* ... Idem */ }
    
    // =============================================
    // üöÄ INITIALIZATION
    // =============================================
    window.onload = () => {
        // Assign DOM elements
        voiceCircle = document.getElementById('voice-circle');
        statusText = document.getElementById('status-text');
        toggleButton = document.getElementById('toggleButton');
        toggleIconEl = document.getElementById('toggleIconEl');
        toggleText = document.getElementById('toggleText');
        ttsAudio = document.getElementById('ttsAudio');
        modeContinu = document.getElementById('modeContinu');
        modePushToTalk = document.getElementById('modePushToTalk');

        updateStatus("Pr√™t", "power-off", "");
        updateButtonState();

        // Attach event listeners
        toggleButton.onclick = handleMasterToggle;
        modeContinu.onclick = () => { if (isContinuRecording || isPushToTalkRecording) stopAllRecording(); recordingMode = 'continu'; updateButtonState(); };
        modePushToTalk.onclick = () => { if (isContinuRecording || isPushToTalkRecording) stopAllRecording(); recordingMode = 'push-to-talk'; updateButtonState(); };
        
        // Setup simple UI interactions
        document.getElementById('send-button').onclick = () => {
            const textInput = document.getElementById('text-input');
            if (textInput.value.trim()) processUserMessage(textInput.value.trim());
            textInput.value = '';
        };

        // Drawer functionality
        const conversationDrawer = document.getElementById('conversationDrawer');
        const settingsDrawer = document.getElementById('settingsDrawer');
        const drawerOverlay = document.getElementById('drawerOverlay');
        const closeDrawers = () => {
            conversationDrawer.classList.add('-translate-x-full');
            settingsDrawer.classList.add('translate-x-full');
            drawerOverlay.classList.add('opacity-0', 'pointer-events-none');
        };
        document.getElementById('conversationToggle').onclick = () => { conversationDrawer.classList.remove('-translate-x-full'); drawerOverlay.classList.remove('opacity-0', 'pointer-events-none'); };
        document.getElementById('drawerToggle').onclick = () => { settingsDrawer.classList.remove('translate-x-full'); drawerOverlay.classList.remove('opacity-0', 'pointer-events-none'); };
        document.getElementById('conversationDrawerClose').onclick = closeDrawers;
        document.getElementById('settingsDrawerClose').onclick = closeDrawers;
        drawerOverlay.onclick = closeDrawers;

        lucide.createIcons();
        log('üéØ Syst√®me initialis√©. En attente d\'interaction.', 'success');
        window.onbeforeunload = stopAllRecording;
    };
    </script>
</body>
</html>